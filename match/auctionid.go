package match

import (
	"encoding/hex"
	"fmt"
)

// AuctionID represents an auction's unique ID.
// This is a byte array alias because sometimes the ID will be
// represented as text, and sometimes it will be represented as bytes.
// We conform it to the BinaryMarshaler interface and TextMarshaler
// interface.
type AuctionID [32]byte

// MarshalBinary encodes the receiver into a binary form and returns
// the result. This conforms to the BinaryMarshaler interface
func (a *AuctionID) MarshalBinary() (data []byte, err error) {
	dataBacking := [32]byte{}
	copy(dataBacking[:], a[:])
	data = dataBacking[:]
	return
}

// UnmarshalBinary decodes the form generated by MarshalBinary.
// This conforms to the BinaryMarshaler interface
func (a *AuctionID) UnmarshalBinary(data []byte) (err error) {
	if len(data) != 32 {
		err = fmt.Errorf("Error unmarshalling AuctionID from binary, cannot unmarshal a slice that isn't 32 bytes long")
		return
	}
	copy(a[:], data)
	return
}

// MarshalText encodes the receiver into UTF-8-encoded text and
// returns the result.
// This conforms to the TextMarshaler interface
func (a *AuctionID) MarshalText() (text []byte, err error) {
	text = []byte(hex.EncodeToString(a[:]))
	return
}

// UnmarshalText deocdes the form generated by MarshalText.
// This conforms to the TextMarshaler interface
func (a *AuctionID) UnmarshalText(text []byte) (err error) {
	if _, err = hex.Decode(a[:], text); err != nil {
		err = fmt.Errorf("Error unmarshalling text AuctionID: %s", err)
		return
	}
	return
}
